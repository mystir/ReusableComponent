{
  "version": 3,
  "sources": ["../../workbox-core/_private/canConstructResponseFromBodyStream.js", "../../workbox-core/copyResponse.js", "../../workbox-precaching/_version.js", "../../workbox-precaching/PrecacheStrategy.js", "../../workbox-core/_private/waitUntil.js", "../../workbox-precaching/utils/createCacheKey.js", "../../workbox-precaching/utils/PrecacheInstallReportPlugin.js", "../../workbox-precaching/utils/PrecacheCacheKeyPlugin.js", "../../workbox-precaching/utils/printCleanupDetails.js", "../../workbox-precaching/utils/printInstallDetails.js", "../../workbox-precaching/PrecacheController.js", "../../workbox-precaching/utils/getOrCreatePrecacheController.js", "../../workbox-precaching/matchPrecache.js"],
  "sourcesContent": ["/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\nlet supportStatus;\n/**\n * A utility function that determines whether the current browser supports\n * constructing a new `Response` from a `response.body` stream.\n *\n * @return {boolean} `true`, if the current browser can successfully\n *     construct a `Response` from a `response.body` stream, `false` otherwise.\n *\n * @private\n */\nfunction canConstructResponseFromBodyStream() {\n    if (supportStatus === undefined) {\n        const testResponse = new Response('');\n        if ('body' in testResponse) {\n            try {\n                new Response(testResponse.body);\n                supportStatus = true;\n            }\n            catch (error) {\n                supportStatus = false;\n            }\n        }\n        supportStatus = false;\n    }\n    return supportStatus;\n}\nexport { canConstructResponseFromBodyStream };\n", "/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { canConstructResponseFromBodyStream } from './_private/canConstructResponseFromBodyStream.js';\nimport { WorkboxError } from './_private/WorkboxError.js';\nimport './_version.js';\n/**\n * Allows developers to copy a response and modify its `headers`, `status`,\n * or `statusText` values (the values settable via a\n * [`ResponseInit`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Response/Response#Syntax}\n * object in the constructor).\n * To modify these values, pass a function as the second argument. That\n * function will be invoked with a single object with the response properties\n * `{headers, status, statusText}`. The return value of this function will\n * be used as the `ResponseInit` for the new `Response`. To change the values\n * either modify the passed parameter(s) and return it, or return a totally\n * new object.\n *\n * This method is intentionally limited to same-origin responses, regardless of\n * whether CORS was used or not.\n *\n * @param {Response} response\n * @param {Function} modifier\n * @memberof workbox-core\n */\nasync function copyResponse(response, modifier) {\n    let origin = null;\n    // If response.url isn't set, assume it's cross-origin and keep origin null.\n    if (response.url) {\n        const responseURL = new URL(response.url);\n        origin = responseURL.origin;\n    }\n    if (origin !== self.location.origin) {\n        throw new WorkboxError('cross-origin-copy-response', { origin });\n    }\n    const clonedResponse = response.clone();\n    // Create a fresh `ResponseInit` object by cloning the headers.\n    const responseInit = {\n        headers: new Headers(clonedResponse.headers),\n        status: clonedResponse.status,\n        statusText: clonedResponse.statusText,\n    };\n    // Apply any user modifications.\n    const modifiedResponseInit = modifier ? modifier(responseInit) : responseInit;\n    // Create the new response from the body stream and `ResponseInit`\n    // modifications. Note: not all browsers support the Response.body stream,\n    // so fall back to reading the entire body into memory as a blob.\n    const body = canConstructResponseFromBodyStream()\n        ? clonedResponse.body\n        : await clonedResponse.blob();\n    return new Response(body, modifiedResponseInit);\n}\nexport { copyResponse };\n", "\"use strict\";\n// @ts-ignore\ntry {\n    self['workbox:precaching:6.5.3'] && _();\n}\ncatch (e) { }\n", "/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { copyResponse } from 'workbox-core/copyResponse.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { Strategy } from 'workbox-strategies/Strategy.js';\nimport './_version.js';\n/**\n * A {@link workbox-strategies.Strategy} implementation\n * specifically designed to work with\n * {@link workbox-precaching.PrecacheController}\n * to both cache and fetch precached assets.\n *\n * Note: an instance of this class is created automatically when creating a\n * `PrecacheController`; it's generally not necessary to create this yourself.\n *\n * @extends workbox-strategies.Strategy\n * @memberof workbox-precaching\n */\nclass PrecacheStrategy extends Strategy {\n    /**\n     *\n     * @param {Object} [options]\n     * @param {string} [options.cacheName] Cache name to store and retrieve\n     * requests. Defaults to the cache names provided by\n     * {@link workbox-core.cacheNames}.\n     * @param {Array<Object>} [options.plugins] {@link https://developers.google.com/web/tools/workbox/guides/using-plugins|Plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} [options.fetchOptions] Values passed along to the\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters|init}\n     * of all fetch() requests made by this strategy.\n     * @param {Object} [options.matchOptions] The\n     * {@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions|CacheQueryOptions}\n     * for any `cache.match()` or `cache.put()` calls made by this strategy.\n     * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to\n     * get the response from the network if there's a precache miss.\n     */\n    constructor(options = {}) {\n        options.cacheName = cacheNames.getPrecacheName(options.cacheName);\n        super(options);\n        this._fallbackToNetwork =\n            options.fallbackToNetwork === false ? false : true;\n        // Redirected responses cannot be used to satisfy a navigation request, so\n        // any redirected response must be \"copied\" rather than cloned, so the new\n        // response doesn't contain the `redirected` flag. See:\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=669363&desc=2#c1\n        this.plugins.push(PrecacheStrategy.copyRedirectedCacheableResponsesPlugin);\n    }\n    /**\n     * @private\n     * @param {Request|string} request A request to run this strategy for.\n     * @param {workbox-strategies.StrategyHandler} handler The event that\n     *     triggered the request.\n     * @return {Promise<Response>}\n     */\n    async _handle(request, handler) {\n        const response = await handler.cacheMatch(request);\n        if (response) {\n            return response;\n        }\n        // If this is an `install` event for an entry that isn't already cached,\n        // then populate the cache.\n        if (handler.event && handler.event.type === 'install') {\n            return await this._handleInstall(request, handler);\n        }\n        // Getting here means something went wrong. An entry that should have been\n        // precached wasn't found in the cache.\n        return await this._handleFetch(request, handler);\n    }\n    async _handleFetch(request, handler) {\n        let response;\n        const params = (handler.params || {});\n        // Fall back to the network if we're configured to do so.\n        if (this._fallbackToNetwork) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.warn(`The precached response for ` +\n                    `${getFriendlyURL(request.url)} in ${this.cacheName} was not ` +\n                    `found. Falling back to the network.`);\n            }\n            const integrityInManifest = params.integrity;\n            const integrityInRequest = request.integrity;\n            const noIntegrityConflict = !integrityInRequest || integrityInRequest === integrityInManifest;\n            // Do not add integrity if the original request is no-cors\n            // See https://github.com/GoogleChrome/workbox/issues/3096\n            response = await handler.fetch(new Request(request, {\n                integrity: request.mode !== 'no-cors'\n                    ? integrityInRequest || integrityInManifest\n                    : undefined,\n            }));\n            // It's only \"safe\" to repair the cache if we're using SRI to guarantee\n            // that the response matches the precache manifest's expectations,\n            // and there's either a) no integrity property in the incoming request\n            // or b) there is an integrity, and it matches the precache manifest.\n            // See https://github.com/GoogleChrome/workbox/issues/2858\n            // Also if the original request users no-cors we don't use integrity.\n            // See https://github.com/GoogleChrome/workbox/issues/3096\n            if (integrityInManifest &&\n                noIntegrityConflict &&\n                request.mode !== 'no-cors') {\n                this._useDefaultCacheabilityPluginIfNeeded();\n                const wasCached = await handler.cachePut(request, response.clone());\n                if (process.env.NODE_ENV !== 'production') {\n                    if (wasCached) {\n                        logger.log(`A response for ${getFriendlyURL(request.url)} ` +\n                            `was used to \"repair\" the precache.`);\n                    }\n                }\n            }\n        }\n        else {\n            // This shouldn't normally happen, but there are edge cases:\n            // https://github.com/GoogleChrome/workbox/issues/1441\n            throw new WorkboxError('missing-precache-entry', {\n                cacheName: this.cacheName,\n                url: request.url,\n            });\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            const cacheKey = params.cacheKey || (await handler.getCacheKey(request, 'read'));\n            // Workbox is going to handle the route.\n            // print the routing details to the console.\n            logger.groupCollapsed(`Precaching is responding to: ` + getFriendlyURL(request.url));\n            logger.log(`Serving the precached url: ${getFriendlyURL(cacheKey instanceof Request ? cacheKey.url : cacheKey)}`);\n            logger.groupCollapsed(`View request details here.`);\n            logger.log(request);\n            logger.groupEnd();\n            logger.groupCollapsed(`View response details here.`);\n            logger.log(response);\n            logger.groupEnd();\n            logger.groupEnd();\n        }\n        return response;\n    }\n    async _handleInstall(request, handler) {\n        this._useDefaultCacheabilityPluginIfNeeded();\n        const response = await handler.fetch(request);\n        // Make sure we defer cachePut() until after we know the response\n        // should be cached; see https://github.com/GoogleChrome/workbox/issues/2737\n        const wasCached = await handler.cachePut(request, response.clone());\n        if (!wasCached) {\n            // Throwing here will lead to the `install` handler failing, which\n            // we want to do if *any* of the responses aren't safe to cache.\n            throw new WorkboxError('bad-precaching-response', {\n                url: request.url,\n                status: response.status,\n            });\n        }\n        return response;\n    }\n    /**\n     * This method is complex, as there a number of things to account for:\n     *\n     * The `plugins` array can be set at construction, and/or it might be added to\n     * to at any time before the strategy is used.\n     *\n     * At the time the strategy is used (i.e. during an `install` event), there\n     * needs to be at least one plugin that implements `cacheWillUpdate` in the\n     * array, other than `copyRedirectedCacheableResponsesPlugin`.\n     *\n     * - If this method is called and there are no suitable `cacheWillUpdate`\n     * plugins, we need to add `defaultPrecacheCacheabilityPlugin`.\n     *\n     * - If this method is called and there is exactly one `cacheWillUpdate`, then\n     * we don't have to do anything (this might be a previously added\n     * `defaultPrecacheCacheabilityPlugin`, or it might be a custom plugin).\n     *\n     * - If this method is called and there is more than one `cacheWillUpdate`,\n     * then we need to check if one is `defaultPrecacheCacheabilityPlugin`. If so,\n     * we need to remove it. (This situation is unlikely, but it could happen if\n     * the strategy is used multiple times, the first without a `cacheWillUpdate`,\n     * and then later on after manually adding a custom `cacheWillUpdate`.)\n     *\n     * See https://github.com/GoogleChrome/workbox/issues/2737 for more context.\n     *\n     * @private\n     */\n    _useDefaultCacheabilityPluginIfNeeded() {\n        let defaultPluginIndex = null;\n        let cacheWillUpdatePluginCount = 0;\n        for (const [index, plugin] of this.plugins.entries()) {\n            // Ignore the copy redirected plugin when determining what to do.\n            if (plugin === PrecacheStrategy.copyRedirectedCacheableResponsesPlugin) {\n                continue;\n            }\n            // Save the default plugin's index, in case it needs to be removed.\n            if (plugin === PrecacheStrategy.defaultPrecacheCacheabilityPlugin) {\n                defaultPluginIndex = index;\n            }\n            if (plugin.cacheWillUpdate) {\n                cacheWillUpdatePluginCount++;\n            }\n        }\n        if (cacheWillUpdatePluginCount === 0) {\n            this.plugins.push(PrecacheStrategy.defaultPrecacheCacheabilityPlugin);\n        }\n        else if (cacheWillUpdatePluginCount > 1 && defaultPluginIndex !== null) {\n            // Only remove the default plugin; multiple custom plugins are allowed.\n            this.plugins.splice(defaultPluginIndex, 1);\n        }\n        // Nothing needs to be done if cacheWillUpdatePluginCount is 1\n    }\n}\nPrecacheStrategy.defaultPrecacheCacheabilityPlugin = {\n    async cacheWillUpdate({ response }) {\n        if (!response || response.status >= 400) {\n            return null;\n        }\n        return response;\n    },\n};\nPrecacheStrategy.copyRedirectedCacheableResponsesPlugin = {\n    async cacheWillUpdate({ response }) {\n        return response.redirected ? await copyResponse(response) : response;\n    },\n};\nexport { PrecacheStrategy };\n", "/*\n  Copyright 2020 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * A utility method that makes it easier to use `event.waitUntil` with\n * async functions and return the result.\n *\n * @param {ExtendableEvent} event\n * @param {Function} asyncFn\n * @return {Function}\n * @private\n */\nfunction waitUntil(event, asyncFn) {\n    const returnPromise = asyncFn();\n    event.waitUntil(returnPromise);\n    return returnPromise;\n}\nexport { waitUntil };\n", "/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport '../_version.js';\n// Name of the search parameter used to store revision info.\nconst REVISION_SEARCH_PARAM = '__WB_REVISION__';\n/**\n * Converts a manifest entry into a versioned URL suitable for precaching.\n *\n * @param {Object|string} entry\n * @return {string} A URL with versioning info.\n *\n * @private\n * @memberof workbox-precaching\n */\nexport function createCacheKey(entry) {\n    if (!entry) {\n        throw new WorkboxError('add-to-cache-list-unexpected-type', { entry });\n    }\n    // If a precache manifest entry is a string, it's assumed to be a versioned\n    // URL, like '/app.abcd1234.js'. Return as-is.\n    if (typeof entry === 'string') {\n        const urlObject = new URL(entry, location.href);\n        return {\n            cacheKey: urlObject.href,\n            url: urlObject.href,\n        };\n    }\n    const { revision, url } = entry;\n    if (!url) {\n        throw new WorkboxError('add-to-cache-list-unexpected-type', { entry });\n    }\n    // If there's just a URL and no revision, then it's also assumed to be a\n    // versioned URL.\n    if (!revision) {\n        const urlObject = new URL(url, location.href);\n        return {\n            cacheKey: urlObject.href,\n            url: urlObject.href,\n        };\n    }\n    // Otherwise, construct a properly versioned URL using the custom Workbox\n    // search parameter along with the revision info.\n    const cacheKeyURL = new URL(url, location.href);\n    const originalURL = new URL(url, location.href);\n    cacheKeyURL.searchParams.set(REVISION_SEARCH_PARAM, revision);\n    return {\n        cacheKey: cacheKeyURL.href,\n        url: originalURL.href,\n    };\n}\n", "/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * A plugin, designed to be used with PrecacheController, to determine the\n * of assets that were updated (or not updated) during the install event.\n *\n * @private\n */\nclass PrecacheInstallReportPlugin {\n    constructor() {\n        this.updatedURLs = [];\n        this.notUpdatedURLs = [];\n        this.handlerWillStart = async ({ request, state, }) => {\n            // TODO: `state` should never be undefined...\n            if (state) {\n                state.originalRequest = request;\n            }\n        };\n        this.cachedResponseWillBeUsed = async ({ event, state, cachedResponse, }) => {\n            if (event.type === 'install') {\n                if (state &&\n                    state.originalRequest &&\n                    state.originalRequest instanceof Request) {\n                    // TODO: `state` should never be undefined...\n                    const url = state.originalRequest.url;\n                    if (cachedResponse) {\n                        this.notUpdatedURLs.push(url);\n                    }\n                    else {\n                        this.updatedURLs.push(url);\n                    }\n                }\n            }\n            return cachedResponse;\n        };\n    }\n}\nexport { PrecacheInstallReportPlugin };\n", "/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * A plugin, designed to be used with PrecacheController, to translate URLs into\n * the corresponding cache key, based on the current revision info.\n *\n * @private\n */\nclass PrecacheCacheKeyPlugin {\n    constructor({ precacheController }) {\n        this.cacheKeyWillBeUsed = async ({ request, params, }) => {\n            // Params is type any, can't change right now.\n            /* eslint-disable */\n            const cacheKey = (params === null || params === void 0 ? void 0 : params.cacheKey) ||\n                this._precacheController.getCacheKeyForURL(request.url);\n            /* eslint-enable */\n            return cacheKey\n                ? new Request(cacheKey, { headers: request.headers })\n                : request;\n        };\n        this._precacheController = precacheController;\n    }\n}\nexport { PrecacheCacheKeyPlugin };\n", "/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { logger } from 'workbox-core/_private/logger.js';\nimport '../_version.js';\n/**\n * @param {string} groupTitle\n * @param {Array<string>} deletedURLs\n *\n * @private\n */\nconst logGroup = (groupTitle, deletedURLs) => {\n    logger.groupCollapsed(groupTitle);\n    for (const url of deletedURLs) {\n        logger.log(url);\n    }\n    logger.groupEnd();\n};\n/**\n * @param {Array<string>} deletedURLs\n *\n * @private\n * @memberof workbox-precaching\n */\nexport function printCleanupDetails(deletedURLs) {\n    const deletionCount = deletedURLs.length;\n    if (deletionCount > 0) {\n        logger.groupCollapsed(`During precaching cleanup, ` +\n            `${deletionCount} cached ` +\n            `request${deletionCount === 1 ? ' was' : 's were'} deleted.`);\n        logGroup('Deleted Cache Requests', deletedURLs);\n        logger.groupEnd();\n    }\n}\n", "/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { logger } from 'workbox-core/_private/logger.js';\nimport '../_version.js';\n/**\n * @param {string} groupTitle\n * @param {Array<string>} urls\n *\n * @private\n */\nfunction _nestedGroup(groupTitle, urls) {\n    if (urls.length === 0) {\n        return;\n    }\n    logger.groupCollapsed(groupTitle);\n    for (const url of urls) {\n        logger.log(url);\n    }\n    logger.groupEnd();\n}\n/**\n * @param {Array<string>} urlsToPrecache\n * @param {Array<string>} urlsAlreadyPrecached\n *\n * @private\n * @memberof workbox-precaching\n */\nexport function printInstallDetails(urlsToPrecache, urlsAlreadyPrecached) {\n    const precachedCount = urlsToPrecache.length;\n    const alreadyPrecachedCount = urlsAlreadyPrecached.length;\n    if (precachedCount || alreadyPrecachedCount) {\n        let message = `Precaching ${precachedCount} file${precachedCount === 1 ? '' : 's'}.`;\n        if (alreadyPrecachedCount > 0) {\n            message +=\n                ` ${alreadyPrecachedCount} ` +\n                    `file${alreadyPrecachedCount === 1 ? ' is' : 's are'} already cached.`;\n        }\n        logger.groupCollapsed(message);\n        _nestedGroup(`View newly precached URLs.`, urlsToPrecache);\n        _nestedGroup(`View previously precached URLs.`, urlsAlreadyPrecached);\n        logger.groupEnd();\n    }\n}\n", "/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { waitUntil } from 'workbox-core/_private/waitUntil.js';\nimport { createCacheKey } from './utils/createCacheKey.js';\nimport { PrecacheInstallReportPlugin } from './utils/PrecacheInstallReportPlugin.js';\nimport { PrecacheCacheKeyPlugin } from './utils/PrecacheCacheKeyPlugin.js';\nimport { printCleanupDetails } from './utils/printCleanupDetails.js';\nimport { printInstallDetails } from './utils/printInstallDetails.js';\nimport { PrecacheStrategy } from './PrecacheStrategy.js';\nimport './_version.js';\n/**\n * Performs efficient precaching of assets.\n *\n * @memberof workbox-precaching\n */\nclass PrecacheController {\n    /**\n     * Create a new PrecacheController.\n     *\n     * @param {Object} [options]\n     * @param {string} [options.cacheName] The cache to use for precaching.\n     * @param {string} [options.plugins] Plugins to use when precaching as well\n     * as responding to fetch events for precached assets.\n     * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to\n     * get the response from the network if there's a precache miss.\n     */\n    constructor({ cacheName, plugins = [], fallbackToNetwork = true, } = {}) {\n        this._urlsToCacheKeys = new Map();\n        this._urlsToCacheModes = new Map();\n        this._cacheKeysToIntegrities = new Map();\n        this._strategy = new PrecacheStrategy({\n            cacheName: cacheNames.getPrecacheName(cacheName),\n            plugins: [\n                ...plugins,\n                new PrecacheCacheKeyPlugin({ precacheController: this }),\n            ],\n            fallbackToNetwork,\n        });\n        // Bind the install and activate methods to the instance.\n        this.install = this.install.bind(this);\n        this.activate = this.activate.bind(this);\n    }\n    /**\n     * @type {workbox-precaching.PrecacheStrategy} The strategy created by this controller and\n     * used to cache assets and respond to fetch events.\n     */\n    get strategy() {\n        return this._strategy;\n    }\n    /**\n     * Adds items to the precache list, removing any duplicates and\n     * stores the files in the\n     * {@link workbox-core.cacheNames|\"precache cache\"} when the service\n     * worker installs.\n     *\n     * This method can be called multiple times.\n     *\n     * @param {Array<Object|string>} [entries=[]] Array of entries to precache.\n     */\n    precache(entries) {\n        this.addToCacheList(entries);\n        if (!this._installAndActiveListenersAdded) {\n            self.addEventListener('install', this.install);\n            self.addEventListener('activate', this.activate);\n            this._installAndActiveListenersAdded = true;\n        }\n    }\n    /**\n     * This method will add items to the precache list, removing duplicates\n     * and ensuring the information is valid.\n     *\n     * @param {Array<workbox-precaching.PrecacheController.PrecacheEntry|string>} entries\n     *     Array of entries to precache.\n     */\n    addToCacheList(entries) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isArray(entries, {\n                moduleName: 'workbox-precaching',\n                className: 'PrecacheController',\n                funcName: 'addToCacheList',\n                paramName: 'entries',\n            });\n        }\n        const urlsToWarnAbout = [];\n        for (const entry of entries) {\n            // See https://github.com/GoogleChrome/workbox/issues/2259\n            if (typeof entry === 'string') {\n                urlsToWarnAbout.push(entry);\n            }\n            else if (entry && entry.revision === undefined) {\n                urlsToWarnAbout.push(entry.url);\n            }\n            const { cacheKey, url } = createCacheKey(entry);\n            const cacheMode = typeof entry !== 'string' && entry.revision ? 'reload' : 'default';\n            if (this._urlsToCacheKeys.has(url) &&\n                this._urlsToCacheKeys.get(url) !== cacheKey) {\n                throw new WorkboxError('add-to-cache-list-conflicting-entries', {\n                    firstEntry: this._urlsToCacheKeys.get(url),\n                    secondEntry: cacheKey,\n                });\n            }\n            if (typeof entry !== 'string' && entry.integrity) {\n                if (this._cacheKeysToIntegrities.has(cacheKey) &&\n                    this._cacheKeysToIntegrities.get(cacheKey) !== entry.integrity) {\n                    throw new WorkboxError('add-to-cache-list-conflicting-integrities', {\n                        url,\n                    });\n                }\n                this._cacheKeysToIntegrities.set(cacheKey, entry.integrity);\n            }\n            this._urlsToCacheKeys.set(url, cacheKey);\n            this._urlsToCacheModes.set(url, cacheMode);\n            if (urlsToWarnAbout.length > 0) {\n                const warningMessage = `Workbox is precaching URLs without revision ` +\n                    `info: ${urlsToWarnAbout.join(', ')}\\nThis is generally NOT safe. ` +\n                    `Learn more at https://bit.ly/wb-precache`;\n                if (process.env.NODE_ENV === 'production') {\n                    // Use console directly to display this warning without bloating\n                    // bundle sizes by pulling in all of the logger codebase in prod.\n                    console.warn(warningMessage);\n                }\n                else {\n                    logger.warn(warningMessage);\n                }\n            }\n        }\n    }\n    /**\n     * Precaches new and updated assets. Call this method from the service worker\n     * install event.\n     *\n     * Note: this method calls `event.waitUntil()` for you, so you do not need\n     * to call it yourself in your event handlers.\n     *\n     * @param {ExtendableEvent} event\n     * @return {Promise<workbox-precaching.InstallResult>}\n     */\n    install(event) {\n        // waitUntil returns Promise<any>\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return waitUntil(event, async () => {\n            const installReportPlugin = new PrecacheInstallReportPlugin();\n            this.strategy.plugins.push(installReportPlugin);\n            // Cache entries one at a time.\n            // See https://github.com/GoogleChrome/workbox/issues/2528\n            for (const [url, cacheKey] of this._urlsToCacheKeys) {\n                const integrity = this._cacheKeysToIntegrities.get(cacheKey);\n                const cacheMode = this._urlsToCacheModes.get(url);\n                const request = new Request(url, {\n                    integrity,\n                    cache: cacheMode,\n                    credentials: 'same-origin',\n                });\n                await Promise.all(this.strategy.handleAll({\n                    params: { cacheKey },\n                    request,\n                    event,\n                }));\n            }\n            const { updatedURLs, notUpdatedURLs } = installReportPlugin;\n            if (process.env.NODE_ENV !== 'production') {\n                printInstallDetails(updatedURLs, notUpdatedURLs);\n            }\n            return { updatedURLs, notUpdatedURLs };\n        });\n    }\n    /**\n     * Deletes assets that are no longer present in the current precache manifest.\n     * Call this method from the service worker activate event.\n     *\n     * Note: this method calls `event.waitUntil()` for you, so you do not need\n     * to call it yourself in your event handlers.\n     *\n     * @param {ExtendableEvent} event\n     * @return {Promise<workbox-precaching.CleanupResult>}\n     */\n    activate(event) {\n        // waitUntil returns Promise<any>\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return waitUntil(event, async () => {\n            const cache = await self.caches.open(this.strategy.cacheName);\n            const currentlyCachedRequests = await cache.keys();\n            const expectedCacheKeys = new Set(this._urlsToCacheKeys.values());\n            const deletedURLs = [];\n            for (const request of currentlyCachedRequests) {\n                if (!expectedCacheKeys.has(request.url)) {\n                    await cache.delete(request);\n                    deletedURLs.push(request.url);\n                }\n            }\n            if (process.env.NODE_ENV !== 'production') {\n                printCleanupDetails(deletedURLs);\n            }\n            return { deletedURLs };\n        });\n    }\n    /**\n     * Returns a mapping of a precached URL to the corresponding cache key, taking\n     * into account the revision information for the URL.\n     *\n     * @return {Map<string, string>} A URL to cache key mapping.\n     */\n    getURLsToCacheKeys() {\n        return this._urlsToCacheKeys;\n    }\n    /**\n     * Returns a list of all the URLs that have been precached by the current\n     * service worker.\n     *\n     * @return {Array<string>} The precached URLs.\n     */\n    getCachedURLs() {\n        return [...this._urlsToCacheKeys.keys()];\n    }\n    /**\n     * Returns the cache key used for storing a given URL. If that URL is\n     * unversioned, like `/index.html', then the cache key will be the original\n     * URL with a search parameter appended to it.\n     *\n     * @param {string} url A URL whose cache key you want to look up.\n     * @return {string} The versioned URL that corresponds to a cache key\n     * for the original URL, or undefined if that URL isn't precached.\n     */\n    getCacheKeyForURL(url) {\n        const urlObject = new URL(url, location.href);\n        return this._urlsToCacheKeys.get(urlObject.href);\n    }\n    /**\n     * @param {string} url A cache key whose SRI you want to look up.\n     * @return {string} The subresource integrity associated with the cache key,\n     * or undefined if it's not set.\n     */\n    getIntegrityForCacheKey(cacheKey) {\n        return this._cacheKeysToIntegrities.get(cacheKey);\n    }\n    /**\n     * This acts as a drop-in replacement for\n     * [`cache.match()`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match)\n     * with the following differences:\n     *\n     * - It knows what the name of the precache is, and only checks in that cache.\n     * - It allows you to pass in an \"original\" URL without versioning parameters,\n     * and it will automatically look up the correct cache key for the currently\n     * active revision of that URL.\n     *\n     * E.g., `matchPrecache('index.html')` will find the correct precached\n     * response for the currently active service worker, even if the actual cache\n     * key is `'/index.html?__WB_REVISION__=1234abcd'`.\n     *\n     * @param {string|Request} request The key (without revisioning parameters)\n     * to look up in the precache.\n     * @return {Promise<Response|undefined>}\n     */\n    async matchPrecache(request) {\n        const url = request instanceof Request ? request.url : request;\n        const cacheKey = this.getCacheKeyForURL(url);\n        if (cacheKey) {\n            const cache = await self.caches.open(this.strategy.cacheName);\n            return cache.match(cacheKey);\n        }\n        return undefined;\n    }\n    /**\n     * Returns a function that looks up `url` in the precache (taking into\n     * account revision information), and returns the corresponding `Response`.\n     *\n     * @param {string} url The precached URL which will be used to lookup the\n     * `Response`.\n     * @return {workbox-routing~handlerCallback}\n     */\n    createHandlerBoundToURL(url) {\n        const cacheKey = this.getCacheKeyForURL(url);\n        if (!cacheKey) {\n            throw new WorkboxError('non-precached-url', { url });\n        }\n        return (options) => {\n            options.request = new Request(url);\n            options.params = Object.assign({ cacheKey }, options.params);\n            return this.strategy.handle(options);\n        };\n    }\n}\nexport { PrecacheController };\n", "/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { PrecacheController } from '../PrecacheController.js';\nimport '../_version.js';\nlet precacheController;\n/**\n * @return {PrecacheController}\n * @private\n */\nexport const getOrCreatePrecacheController = () => {\n    if (!precacheController) {\n        precacheController = new PrecacheController();\n    }\n    return precacheController;\n};\n", "/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { getOrCreatePrecacheController } from './utils/getOrCreatePrecacheController.js';\nimport './_version.js';\n/**\n * Helper function that calls\n * {@link PrecacheController#matchPrecache} on the default\n * {@link PrecacheController} instance.\n *\n * If you are creating your own {@link PrecacheController}, then call\n * {@link PrecacheController#matchPrecache} on that instance,\n * instead of using this function.\n *\n * @param {string|Request} request The key (without revisioning parameters)\n * to look up in the precache.\n * @return {Promise<Response|undefined>}\n *\n * @memberof workbox-precaching\n */\nfunction matchPrecache(request) {\n    const precacheController = getOrCreatePrecacheController();\n    return precacheController.matchPrecache(request);\n}\nexport { matchPrecache };\n"],
  "mappings": "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",
  "names": ["precacheController", "precacheController"]
}
