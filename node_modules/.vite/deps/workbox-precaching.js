import {
  PrecacheController,
  PrecacheStrategy,
  getOrCreatePrecacheController,
  matchPrecache
} from "./chunk-4M6PIRZB.js";
import {
  Route,
  registerRoute
} from "./chunk-OOSULOWM.js";
import {
  cacheNames
} from "./chunk-JLG4UK6U.js";
import {
  getFriendlyURL,
  logger
} from "./chunk-E6WMX4CF.js";
import "./chunk-S5KM4IGW.js";

// node_modules/workbox-precaching/addPlugins.js
function addPlugins(plugins) {
  const precacheController = getOrCreatePrecacheController();
  precacheController.strategy.plugins.push(...plugins);
}

// node_modules/workbox-precaching/utils/removeIgnoredSearchParams.js
function removeIgnoredSearchParams(urlObject, ignoreURLParametersMatching = []) {
  for (const paramName of [...urlObject.searchParams.keys()]) {
    if (ignoreURLParametersMatching.some((regExp) => regExp.test(paramName))) {
      urlObject.searchParams.delete(paramName);
    }
  }
  return urlObject;
}

// node_modules/workbox-precaching/utils/generateURLVariations.js
function* generateURLVariations(url, { ignoreURLParametersMatching = [/^utm_/, /^fbclid$/], directoryIndex = "index.html", cleanURLs = true, urlManipulation } = {}) {
  const urlObject = new URL(url, location.href);
  urlObject.hash = "";
  yield urlObject.href;
  const urlWithoutIgnoredParams = removeIgnoredSearchParams(urlObject, ignoreURLParametersMatching);
  yield urlWithoutIgnoredParams.href;
  if (directoryIndex && urlWithoutIgnoredParams.pathname.endsWith("/")) {
    const directoryURL = new URL(urlWithoutIgnoredParams.href);
    directoryURL.pathname += directoryIndex;
    yield directoryURL.href;
  }
  if (cleanURLs) {
    const cleanURL = new URL(urlWithoutIgnoredParams.href);
    cleanURL.pathname += ".html";
    yield cleanURL.href;
  }
  if (urlManipulation) {
    const additionalURLs = urlManipulation({ url: urlObject });
    for (const urlToAttempt of additionalURLs) {
      yield urlToAttempt.href;
    }
  }
}

// node_modules/workbox-precaching/PrecacheRoute.js
var PrecacheRoute = class extends Route {
  constructor(precacheController, options) {
    const match = ({ request }) => {
      const urlsToCacheKeys = precacheController.getURLsToCacheKeys();
      for (const possibleURL of generateURLVariations(request.url, options)) {
        const cacheKey = urlsToCacheKeys.get(possibleURL);
        if (cacheKey) {
          const integrity = precacheController.getIntegrityForCacheKey(cacheKey);
          return { cacheKey, integrity };
        }
      }
      if (true) {
        logger.debug(`Precaching did not find a match for ` + getFriendlyURL(request.url));
      }
      return;
    };
    super(match, precacheController.strategy);
  }
};

// node_modules/workbox-precaching/addRoute.js
function addRoute(options) {
  const precacheController = getOrCreatePrecacheController();
  const precacheRoute = new PrecacheRoute(precacheController, options);
  registerRoute(precacheRoute);
}

// node_modules/workbox-precaching/utils/deleteOutdatedCaches.js
var SUBSTRING_TO_FIND = "-precache-";
var deleteOutdatedCaches = async (currentPrecacheName, substringToFind = SUBSTRING_TO_FIND) => {
  const cacheNames2 = await self.caches.keys();
  const cacheNamesToDelete = cacheNames2.filter((cacheName) => {
    return cacheName.includes(substringToFind) && cacheName.includes(self.registration.scope) && cacheName !== currentPrecacheName;
  });
  await Promise.all(cacheNamesToDelete.map((cacheName) => self.caches.delete(cacheName)));
  return cacheNamesToDelete;
};

// node_modules/workbox-precaching/cleanupOutdatedCaches.js
function cleanupOutdatedCaches() {
  self.addEventListener("activate", (event) => {
    const cacheName = cacheNames.getPrecacheName();
    event.waitUntil(deleteOutdatedCaches(cacheName).then((cachesDeleted) => {
      if (true) {
        if (cachesDeleted.length > 0) {
          logger.log(`The following out-of-date precaches were cleaned up automatically:`, cachesDeleted);
        }
      }
    }));
  });
}

// node_modules/workbox-precaching/createHandlerBoundToURL.js
function createHandlerBoundToURL(url) {
  const precacheController = getOrCreatePrecacheController();
  return precacheController.createHandlerBoundToURL(url);
}

// node_modules/workbox-precaching/getCacheKeyForURL.js
function getCacheKeyForURL(url) {
  const precacheController = getOrCreatePrecacheController();
  return precacheController.getCacheKeyForURL(url);
}

// node_modules/workbox-precaching/precache.js
function precache(entries) {
  const precacheController = getOrCreatePrecacheController();
  precacheController.precache(entries);
}

// node_modules/workbox-precaching/precacheAndRoute.js
function precacheAndRoute(entries, options) {
  precache(entries);
  addRoute(options);
}

// node_modules/workbox-precaching/PrecacheFallbackPlugin.js
var PrecacheFallbackPlugin = class {
  constructor({ fallbackURL, precacheController }) {
    this.handlerDidError = () => this._precacheController.matchPrecache(this._fallbackURL);
    this._fallbackURL = fallbackURL;
    this._precacheController = precacheController || getOrCreatePrecacheController();
  }
};
export {
  PrecacheController,
  PrecacheFallbackPlugin,
  PrecacheRoute,
  PrecacheStrategy,
  addPlugins,
  addRoute,
  cleanupOutdatedCaches,
  createHandlerBoundToURL,
  getCacheKeyForURL,
  matchPrecache,
  precache,
  precacheAndRoute
};
//# sourceMappingURL=workbox-precaching.js.map
