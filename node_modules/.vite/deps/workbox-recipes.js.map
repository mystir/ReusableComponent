{
  "version": 3,
  "sources": ["../../workbox-cacheable-response/_version.js", "../../workbox-cacheable-response/CacheableResponse.js", "../../workbox-cacheable-response/CacheableResponsePlugin.js", "../../workbox-core/_private/dontWaitFor.js", "../../workbox-core/registerQuotaErrorCallback.js", "../../workbox-expiration/_version.js", "../../workbox-expiration/models/CacheTimestampsModel.js", "../../workbox-expiration/CacheExpiration.js", "../../workbox-expiration/ExpirationPlugin.js", "../../workbox-recipes/_version.js", "../../workbox-recipes/googleFontsCache.js", "../../workbox-recipes/warmStrategyCache.js", "../../workbox-recipes/imageCache.js", "../../workbox-recipes/staticResourceCache.js", "../../workbox-recipes/pageCache.js", "../../workbox-recipes/offlineFallback.js"],
  "sourcesContent": ["\"use strict\";\n// @ts-ignore\ntry {\n    self['workbox:cacheable-response:6.5.3'] && _();\n}\ncatch (e) { }\n", "/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport './_version.js';\n/**\n * This class allows you to set up rules determining what\n * status codes and/or headers need to be present in order for a\n * [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response)\n * to be considered cacheable.\n *\n * @memberof workbox-cacheable-response\n */\nclass CacheableResponse {\n    /**\n     * To construct a new CacheableResponse instance you must provide at least\n     * one of the `config` properties.\n     *\n     * If both `statuses` and `headers` are specified, then both conditions must\n     * be met for the `Response` to be considered cacheable.\n     *\n     * @param {Object} config\n     * @param {Array<number>} [config.statuses] One or more status codes that a\n     * `Response` can have and be considered cacheable.\n     * @param {Object<string,string>} [config.headers] A mapping of header names\n     * and expected values that a `Response` can have and be considered cacheable.\n     * If multiple headers are provided, only one needs to be present.\n     */\n    constructor(config = {}) {\n        if (process.env.NODE_ENV !== 'production') {\n            if (!(config.statuses || config.headers)) {\n                throw new WorkboxError('statuses-or-headers-required', {\n                    moduleName: 'workbox-cacheable-response',\n                    className: 'CacheableResponse',\n                    funcName: 'constructor',\n                });\n            }\n            if (config.statuses) {\n                assert.isArray(config.statuses, {\n                    moduleName: 'workbox-cacheable-response',\n                    className: 'CacheableResponse',\n                    funcName: 'constructor',\n                    paramName: 'config.statuses',\n                });\n            }\n            if (config.headers) {\n                assert.isType(config.headers, 'object', {\n                    moduleName: 'workbox-cacheable-response',\n                    className: 'CacheableResponse',\n                    funcName: 'constructor',\n                    paramName: 'config.headers',\n                });\n            }\n        }\n        this._statuses = config.statuses;\n        this._headers = config.headers;\n    }\n    /**\n     * Checks a response to see whether it's cacheable or not, based on this\n     * object's configuration.\n     *\n     * @param {Response} response The response whose cacheability is being\n     * checked.\n     * @return {boolean} `true` if the `Response` is cacheable, and `false`\n     * otherwise.\n     */\n    isResponseCacheable(response) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(response, Response, {\n                moduleName: 'workbox-cacheable-response',\n                className: 'CacheableResponse',\n                funcName: 'isResponseCacheable',\n                paramName: 'response',\n            });\n        }\n        let cacheable = true;\n        if (this._statuses) {\n            cacheable = this._statuses.includes(response.status);\n        }\n        if (this._headers && cacheable) {\n            cacheable = Object.keys(this._headers).some((headerName) => {\n                return response.headers.get(headerName) === this._headers[headerName];\n            });\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            if (!cacheable) {\n                logger.groupCollapsed(`The request for ` +\n                    `'${getFriendlyURL(response.url)}' returned a response that does ` +\n                    `not meet the criteria for being cached.`);\n                logger.groupCollapsed(`View cacheability criteria here.`);\n                logger.log(`Cacheable statuses: ` + JSON.stringify(this._statuses));\n                logger.log(`Cacheable headers: ` + JSON.stringify(this._headers, null, 2));\n                logger.groupEnd();\n                const logFriendlyHeaders = {};\n                response.headers.forEach((value, key) => {\n                    logFriendlyHeaders[key] = value;\n                });\n                logger.groupCollapsed(`View response status and headers here.`);\n                logger.log(`Response status: ${response.status}`);\n                logger.log(`Response headers: ` + JSON.stringify(logFriendlyHeaders, null, 2));\n                logger.groupEnd();\n                logger.groupCollapsed(`View full response details here.`);\n                logger.log(response.headers);\n                logger.log(response);\n                logger.groupEnd();\n                logger.groupEnd();\n            }\n        }\n        return cacheable;\n    }\n}\nexport { CacheableResponse };\n", "/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { CacheableResponse, } from './CacheableResponse.js';\nimport './_version.js';\n/**\n * A class implementing the `cacheWillUpdate` lifecycle callback. This makes it\n * easier to add in cacheability checks to requests made via Workbox's built-in\n * strategies.\n *\n * @memberof workbox-cacheable-response\n */\nclass CacheableResponsePlugin {\n    /**\n     * To construct a new CacheableResponsePlugin instance you must provide at\n     * least one of the `config` properties.\n     *\n     * If both `statuses` and `headers` are specified, then both conditions must\n     * be met for the `Response` to be considered cacheable.\n     *\n     * @param {Object} config\n     * @param {Array<number>} [config.statuses] One or more status codes that a\n     * `Response` can have and be considered cacheable.\n     * @param {Object<string,string>} [config.headers] A mapping of header names\n     * and expected values that a `Response` can have and be considered cacheable.\n     * If multiple headers are provided, only one needs to be present.\n     */\n    constructor(config) {\n        /**\n         * @param {Object} options\n         * @param {Response} options.response\n         * @return {Response|null}\n         * @private\n         */\n        this.cacheWillUpdate = async ({ response }) => {\n            if (this._cacheableResponse.isResponseCacheable(response)) {\n                return response;\n            }\n            return null;\n        };\n        this._cacheableResponse = new CacheableResponse(config);\n    }\n}\nexport { CacheableResponsePlugin };\n", "/*\n  Copyright 2019 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * A helper function that prevents a promise from being flagged as unused.\n *\n * @private\n **/\nexport function dontWaitFor(promise) {\n    // Effective no-op.\n    void promise.then(() => { });\n}\n", "/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { logger } from './_private/logger.js';\nimport { assert } from './_private/assert.js';\nimport { quotaErrorCallbacks } from './models/quotaErrorCallbacks.js';\nimport './_version.js';\n/**\n * Adds a function to the set of quotaErrorCallbacks that will be executed if\n * there's a quota error.\n *\n * @param {Function} callback\n * @memberof workbox-core\n */\n// Can't change Function type\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction registerQuotaErrorCallback(callback) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isType(callback, 'function', {\n            moduleName: 'workbox-core',\n            funcName: 'register',\n            paramName: 'callback',\n        });\n    }\n    quotaErrorCallbacks.add(callback);\n    if (process.env.NODE_ENV !== 'production') {\n        logger.log('Registered a callback to respond to quota errors.', callback);\n    }\n}\nexport { registerQuotaErrorCallback };\n", "\"use strict\";\n// @ts-ignore\ntry {\n    self['workbox:expiration:6.5.3'] && _();\n}\ncatch (e) { }\n", "/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { openDB, deleteDB } from 'idb';\nimport '../_version.js';\nconst DB_NAME = 'workbox-expiration';\nconst CACHE_OBJECT_STORE = 'cache-entries';\nconst normalizeURL = (unNormalizedUrl) => {\n    const url = new URL(unNormalizedUrl, location.href);\n    url.hash = '';\n    return url.href;\n};\n/**\n * Returns the timestamp model.\n *\n * @private\n */\nclass CacheTimestampsModel {\n    /**\n     *\n     * @param {string} cacheName\n     *\n     * @private\n     */\n    constructor(cacheName) {\n        this._db = null;\n        this._cacheName = cacheName;\n    }\n    /**\n     * Performs an upgrade of indexedDB.\n     *\n     * @param {IDBPDatabase<CacheDbSchema>} db\n     *\n     * @private\n     */\n    _upgradeDb(db) {\n        // TODO(philipwalton): EdgeHTML doesn't support arrays as a keyPath, so we\n        // have to use the `id` keyPath here and create our own values (a\n        // concatenation of `url + cacheName`) instead of simply using\n        // `keyPath: ['url', 'cacheName']`, which is supported in other browsers.\n        const objStore = db.createObjectStore(CACHE_OBJECT_STORE, { keyPath: 'id' });\n        // TODO(philipwalton): once we don't have to support EdgeHTML, we can\n        // create a single index with the keyPath `['cacheName', 'timestamp']`\n        // instead of doing both these indexes.\n        objStore.createIndex('cacheName', 'cacheName', { unique: false });\n        objStore.createIndex('timestamp', 'timestamp', { unique: false });\n    }\n    /**\n     * Performs an upgrade of indexedDB and deletes deprecated DBs.\n     *\n     * @param {IDBPDatabase<CacheDbSchema>} db\n     *\n     * @private\n     */\n    _upgradeDbAndDeleteOldDbs(db) {\n        this._upgradeDb(db);\n        if (this._cacheName) {\n            void deleteDB(this._cacheName);\n        }\n    }\n    /**\n     * @param {string} url\n     * @param {number} timestamp\n     *\n     * @private\n     */\n    async setTimestamp(url, timestamp) {\n        url = normalizeURL(url);\n        const entry = {\n            url,\n            timestamp,\n            cacheName: this._cacheName,\n            // Creating an ID from the URL and cache name won't be necessary once\n            // Edge switches to Chromium and all browsers we support work with\n            // array keyPaths.\n            id: this._getId(url),\n        };\n        const db = await this.getDb();\n        const tx = db.transaction(CACHE_OBJECT_STORE, 'readwrite', {\n            durability: 'relaxed',\n        });\n        await tx.store.put(entry);\n        await tx.done;\n    }\n    /**\n     * Returns the timestamp stored for a given URL.\n     *\n     * @param {string} url\n     * @return {number | undefined}\n     *\n     * @private\n     */\n    async getTimestamp(url) {\n        const db = await this.getDb();\n        const entry = await db.get(CACHE_OBJECT_STORE, this._getId(url));\n        return entry === null || entry === void 0 ? void 0 : entry.timestamp;\n    }\n    /**\n     * Iterates through all the entries in the object store (from newest to\n     * oldest) and removes entries once either `maxCount` is reached or the\n     * entry's timestamp is less than `minTimestamp`.\n     *\n     * @param {number} minTimestamp\n     * @param {number} maxCount\n     * @return {Array<string>}\n     *\n     * @private\n     */\n    async expireEntries(minTimestamp, maxCount) {\n        const db = await this.getDb();\n        let cursor = await db\n            .transaction(CACHE_OBJECT_STORE)\n            .store.index('timestamp')\n            .openCursor(null, 'prev');\n        const entriesToDelete = [];\n        let entriesNotDeletedCount = 0;\n        while (cursor) {\n            const result = cursor.value;\n            // TODO(philipwalton): once we can use a multi-key index, we\n            // won't have to check `cacheName` here.\n            if (result.cacheName === this._cacheName) {\n                // Delete an entry if it's older than the max age or\n                // if we already have the max number allowed.\n                if ((minTimestamp && result.timestamp < minTimestamp) ||\n                    (maxCount && entriesNotDeletedCount >= maxCount)) {\n                    // TODO(philipwalton): we should be able to delete the\n                    // entry right here, but doing so causes an iteration\n                    // bug in Safari stable (fixed in TP). Instead we can\n                    // store the keys of the entries to delete, and then\n                    // delete the separate transactions.\n                    // https://github.com/GoogleChrome/workbox/issues/1978\n                    // cursor.delete();\n                    // We only need to return the URL, not the whole entry.\n                    entriesToDelete.push(cursor.value);\n                }\n                else {\n                    entriesNotDeletedCount++;\n                }\n            }\n            cursor = await cursor.continue();\n        }\n        // TODO(philipwalton): once the Safari bug in the following issue is fixed,\n        // we should be able to remove this loop and do the entry deletion in the\n        // cursor loop above:\n        // https://github.com/GoogleChrome/workbox/issues/1978\n        const urlsDeleted = [];\n        for (const entry of entriesToDelete) {\n            await db.delete(CACHE_OBJECT_STORE, entry.id);\n            urlsDeleted.push(entry.url);\n        }\n        return urlsDeleted;\n    }\n    /**\n     * Takes a URL and returns an ID that will be unique in the object store.\n     *\n     * @param {string} url\n     * @return {string}\n     *\n     * @private\n     */\n    _getId(url) {\n        // Creating an ID from the URL and cache name won't be necessary once\n        // Edge switches to Chromium and all browsers we support work with\n        // array keyPaths.\n        return this._cacheName + '|' + normalizeURL(url);\n    }\n    /**\n     * Returns an open connection to the database.\n     *\n     * @private\n     */\n    async getDb() {\n        if (!this._db) {\n            this._db = await openDB(DB_NAME, 1, {\n                upgrade: this._upgradeDbAndDeleteOldDbs.bind(this),\n            });\n        }\n        return this._db;\n    }\n}\nexport { CacheTimestampsModel };\n", "/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { dontWaitFor } from 'workbox-core/_private/dontWaitFor.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { CacheTimestampsModel } from './models/CacheTimestampsModel.js';\nimport './_version.js';\n/**\n * The `CacheExpiration` class allows you define an expiration and / or\n * limit on the number of responses stored in a\n * [`Cache`](https://developer.mozilla.org/en-US/docs/Web/API/Cache).\n *\n * @memberof workbox-expiration\n */\nclass CacheExpiration {\n    /**\n     * To construct a new CacheExpiration instance you must provide at least\n     * one of the `config` properties.\n     *\n     * @param {string} cacheName Name of the cache to apply restrictions to.\n     * @param {Object} config\n     * @param {number} [config.maxEntries] The maximum number of entries to cache.\n     * Entries used the least will be removed as the maximum is reached.\n     * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n     * it's treated as stale and removed.\n     * @param {Object} [config.matchOptions] The [`CacheQueryOptions`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete#Parameters)\n     * that will be used when calling `delete()` on the cache.\n     */\n    constructor(cacheName, config = {}) {\n        this._isRunning = false;\n        this._rerunRequested = false;\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isType(cacheName, 'string', {\n                moduleName: 'workbox-expiration',\n                className: 'CacheExpiration',\n                funcName: 'constructor',\n                paramName: 'cacheName',\n            });\n            if (!(config.maxEntries || config.maxAgeSeconds)) {\n                throw new WorkboxError('max-entries-or-age-required', {\n                    moduleName: 'workbox-expiration',\n                    className: 'CacheExpiration',\n                    funcName: 'constructor',\n                });\n            }\n            if (config.maxEntries) {\n                assert.isType(config.maxEntries, 'number', {\n                    moduleName: 'workbox-expiration',\n                    className: 'CacheExpiration',\n                    funcName: 'constructor',\n                    paramName: 'config.maxEntries',\n                });\n            }\n            if (config.maxAgeSeconds) {\n                assert.isType(config.maxAgeSeconds, 'number', {\n                    moduleName: 'workbox-expiration',\n                    className: 'CacheExpiration',\n                    funcName: 'constructor',\n                    paramName: 'config.maxAgeSeconds',\n                });\n            }\n        }\n        this._maxEntries = config.maxEntries;\n        this._maxAgeSeconds = config.maxAgeSeconds;\n        this._matchOptions = config.matchOptions;\n        this._cacheName = cacheName;\n        this._timestampModel = new CacheTimestampsModel(cacheName);\n    }\n    /**\n     * Expires entries for the given cache and given criteria.\n     */\n    async expireEntries() {\n        if (this._isRunning) {\n            this._rerunRequested = true;\n            return;\n        }\n        this._isRunning = true;\n        const minTimestamp = this._maxAgeSeconds\n            ? Date.now() - this._maxAgeSeconds * 1000\n            : 0;\n        const urlsExpired = await this._timestampModel.expireEntries(minTimestamp, this._maxEntries);\n        // Delete URLs from the cache\n        const cache = await self.caches.open(this._cacheName);\n        for (const url of urlsExpired) {\n            await cache.delete(url, this._matchOptions);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            if (urlsExpired.length > 0) {\n                logger.groupCollapsed(`Expired ${urlsExpired.length} ` +\n                    `${urlsExpired.length === 1 ? 'entry' : 'entries'} and removed ` +\n                    `${urlsExpired.length === 1 ? 'it' : 'them'} from the ` +\n                    `'${this._cacheName}' cache.`);\n                logger.log(`Expired the following ${urlsExpired.length === 1 ? 'URL' : 'URLs'}:`);\n                urlsExpired.forEach((url) => logger.log(`    ${url}`));\n                logger.groupEnd();\n            }\n            else {\n                logger.debug(`Cache expiration ran and found no entries to remove.`);\n            }\n        }\n        this._isRunning = false;\n        if (this._rerunRequested) {\n            this._rerunRequested = false;\n            dontWaitFor(this.expireEntries());\n        }\n    }\n    /**\n     * Update the timestamp for the given URL. This ensures the when\n     * removing entries based on maximum entries, most recently used\n     * is accurate or when expiring, the timestamp is up-to-date.\n     *\n     * @param {string} url\n     */\n    async updateTimestamp(url) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isType(url, 'string', {\n                moduleName: 'workbox-expiration',\n                className: 'CacheExpiration',\n                funcName: 'updateTimestamp',\n                paramName: 'url',\n            });\n        }\n        await this._timestampModel.setTimestamp(url, Date.now());\n    }\n    /**\n     * Can be used to check if a URL has expired or not before it's used.\n     *\n     * This requires a look up from IndexedDB, so can be slow.\n     *\n     * Note: This method will not remove the cached entry, call\n     * `expireEntries()` to remove indexedDB and Cache entries.\n     *\n     * @param {string} url\n     * @return {boolean}\n     */\n    async isURLExpired(url) {\n        if (!this._maxAgeSeconds) {\n            if (process.env.NODE_ENV !== 'production') {\n                throw new WorkboxError(`expired-test-without-max-age`, {\n                    methodName: 'isURLExpired',\n                    paramName: 'maxAgeSeconds',\n                });\n            }\n            return false;\n        }\n        else {\n            const timestamp = await this._timestampModel.getTimestamp(url);\n            const expireOlderThan = Date.now() - this._maxAgeSeconds * 1000;\n            return timestamp !== undefined ? timestamp < expireOlderThan : true;\n        }\n    }\n    /**\n     * Removes the IndexedDB object store used to keep track of cache expiration\n     * metadata.\n     */\n    async delete() {\n        // Make sure we don't attempt another rerun if we're called in the middle of\n        // a cache expiration.\n        this._rerunRequested = false;\n        await this._timestampModel.expireEntries(Infinity); // Expires all.\n    }\n}\nexport { CacheExpiration };\n", "/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { dontWaitFor } from 'workbox-core/_private/dontWaitFor.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { registerQuotaErrorCallback } from 'workbox-core/registerQuotaErrorCallback.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { CacheExpiration } from './CacheExpiration.js';\nimport './_version.js';\n/**\n * This plugin can be used in a `workbox-strategy` to regularly enforce a\n * limit on the age and / or the number of cached requests.\n *\n * It can only be used with `workbox-strategy` instances that have a\n * [custom `cacheName` property set](/web/tools/workbox/guides/configure-workbox#custom_cache_names_in_strategies).\n * In other words, it can't be used to expire entries in strategy that uses the\n * default runtime cache name.\n *\n * Whenever a cached response is used or updated, this plugin will look\n * at the associated cache and remove any old or extra responses.\n *\n * When using `maxAgeSeconds`, responses may be used *once* after expiring\n * because the expiration clean up will not have occurred until *after* the\n * cached response has been used. If the response has a \"Date\" header, then\n * a light weight expiration check is performed and the response will not be\n * used immediately.\n *\n * When using `maxEntries`, the entry least-recently requested will be removed\n * from the cache first.\n *\n * @memberof workbox-expiration\n */\nclass ExpirationPlugin {\n    /**\n     * @param {ExpirationPluginOptions} config\n     * @param {number} [config.maxEntries] The maximum number of entries to cache.\n     * Entries used the least will be removed as the maximum is reached.\n     * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n     * it's treated as stale and removed.\n     * @param {Object} [config.matchOptions] The [`CacheQueryOptions`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete#Parameters)\n     * that will be used when calling `delete()` on the cache.\n     * @param {boolean} [config.purgeOnQuotaError] Whether to opt this cache in to\n     * automatic deletion if the available storage quota has been exceeded.\n     */\n    constructor(config = {}) {\n        /**\n         * A \"lifecycle\" callback that will be triggered automatically by the\n         * `workbox-strategies` handlers when a `Response` is about to be returned\n         * from a [Cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache) to\n         * the handler. It allows the `Response` to be inspected for freshness and\n         * prevents it from being used if the `Response`'s `Date` header value is\n         * older than the configured `maxAgeSeconds`.\n         *\n         * @param {Object} options\n         * @param {string} options.cacheName Name of the cache the response is in.\n         * @param {Response} options.cachedResponse The `Response` object that's been\n         *     read from a cache and whose freshness should be checked.\n         * @return {Response} Either the `cachedResponse`, if it's\n         *     fresh, or `null` if the `Response` is older than `maxAgeSeconds`.\n         *\n         * @private\n         */\n        this.cachedResponseWillBeUsed = async ({ event, request, cacheName, cachedResponse, }) => {\n            if (!cachedResponse) {\n                return null;\n            }\n            const isFresh = this._isResponseDateFresh(cachedResponse);\n            // Expire entries to ensure that even if the expiration date has\n            // expired, it'll only be used once.\n            const cacheExpiration = this._getCacheExpiration(cacheName);\n            dontWaitFor(cacheExpiration.expireEntries());\n            // Update the metadata for the request URL to the current timestamp,\n            // but don't `await` it as we don't want to block the response.\n            const updateTimestampDone = cacheExpiration.updateTimestamp(request.url);\n            if (event) {\n                try {\n                    event.waitUntil(updateTimestampDone);\n                }\n                catch (error) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        // The event may not be a fetch event; only log the URL if it is.\n                        if ('request' in event) {\n                            logger.warn(`Unable to ensure service worker stays alive when ` +\n                                `updating cache entry for ` +\n                                `'${getFriendlyURL(event.request.url)}'.`);\n                        }\n                    }\n                }\n            }\n            return isFresh ? cachedResponse : null;\n        };\n        /**\n         * A \"lifecycle\" callback that will be triggered automatically by the\n         * `workbox-strategies` handlers when an entry is added to a cache.\n         *\n         * @param {Object} options\n         * @param {string} options.cacheName Name of the cache that was updated.\n         * @param {string} options.request The Request for the cached entry.\n         *\n         * @private\n         */\n        this.cacheDidUpdate = async ({ cacheName, request, }) => {\n            if (process.env.NODE_ENV !== 'production') {\n                assert.isType(cacheName, 'string', {\n                    moduleName: 'workbox-expiration',\n                    className: 'Plugin',\n                    funcName: 'cacheDidUpdate',\n                    paramName: 'cacheName',\n                });\n                assert.isInstance(request, Request, {\n                    moduleName: 'workbox-expiration',\n                    className: 'Plugin',\n                    funcName: 'cacheDidUpdate',\n                    paramName: 'request',\n                });\n            }\n            const cacheExpiration = this._getCacheExpiration(cacheName);\n            await cacheExpiration.updateTimestamp(request.url);\n            await cacheExpiration.expireEntries();\n        };\n        if (process.env.NODE_ENV !== 'production') {\n            if (!(config.maxEntries || config.maxAgeSeconds)) {\n                throw new WorkboxError('max-entries-or-age-required', {\n                    moduleName: 'workbox-expiration',\n                    className: 'Plugin',\n                    funcName: 'constructor',\n                });\n            }\n            if (config.maxEntries) {\n                assert.isType(config.maxEntries, 'number', {\n                    moduleName: 'workbox-expiration',\n                    className: 'Plugin',\n                    funcName: 'constructor',\n                    paramName: 'config.maxEntries',\n                });\n            }\n            if (config.maxAgeSeconds) {\n                assert.isType(config.maxAgeSeconds, 'number', {\n                    moduleName: 'workbox-expiration',\n                    className: 'Plugin',\n                    funcName: 'constructor',\n                    paramName: 'config.maxAgeSeconds',\n                });\n            }\n        }\n        this._config = config;\n        this._maxAgeSeconds = config.maxAgeSeconds;\n        this._cacheExpirations = new Map();\n        if (config.purgeOnQuotaError) {\n            registerQuotaErrorCallback(() => this.deleteCacheAndMetadata());\n        }\n    }\n    /**\n     * A simple helper method to return a CacheExpiration instance for a given\n     * cache name.\n     *\n     * @param {string} cacheName\n     * @return {CacheExpiration}\n     *\n     * @private\n     */\n    _getCacheExpiration(cacheName) {\n        if (cacheName === cacheNames.getRuntimeName()) {\n            throw new WorkboxError('expire-custom-caches-only');\n        }\n        let cacheExpiration = this._cacheExpirations.get(cacheName);\n        if (!cacheExpiration) {\n            cacheExpiration = new CacheExpiration(cacheName, this._config);\n            this._cacheExpirations.set(cacheName, cacheExpiration);\n        }\n        return cacheExpiration;\n    }\n    /**\n     * @param {Response} cachedResponse\n     * @return {boolean}\n     *\n     * @private\n     */\n    _isResponseDateFresh(cachedResponse) {\n        if (!this._maxAgeSeconds) {\n            // We aren't expiring by age, so return true, it's fresh\n            return true;\n        }\n        // Check if the 'date' header will suffice a quick expiration check.\n        // See https://github.com/GoogleChromeLabs/sw-toolbox/issues/164 for\n        // discussion.\n        const dateHeaderTimestamp = this._getDateHeaderTimestamp(cachedResponse);\n        if (dateHeaderTimestamp === null) {\n            // Unable to parse date, so assume it's fresh.\n            return true;\n        }\n        // If we have a valid headerTime, then our response is fresh iff the\n        // headerTime plus maxAgeSeconds is greater than the current time.\n        const now = Date.now();\n        return dateHeaderTimestamp >= now - this._maxAgeSeconds * 1000;\n    }\n    /**\n     * This method will extract the data header and parse it into a useful\n     * value.\n     *\n     * @param {Response} cachedResponse\n     * @return {number|null}\n     *\n     * @private\n     */\n    _getDateHeaderTimestamp(cachedResponse) {\n        if (!cachedResponse.headers.has('date')) {\n            return null;\n        }\n        const dateHeader = cachedResponse.headers.get('date');\n        const parsedDate = new Date(dateHeader);\n        const headerTime = parsedDate.getTime();\n        // If the Date header was invalid for some reason, parsedDate.getTime()\n        // will return NaN.\n        if (isNaN(headerTime)) {\n            return null;\n        }\n        return headerTime;\n    }\n    /**\n     * This is a helper method that performs two operations:\n     *\n     * - Deletes *all* the underlying Cache instances associated with this plugin\n     * instance, by calling caches.delete() on your behalf.\n     * - Deletes the metadata from IndexedDB used to keep track of expiration\n     * details for each Cache instance.\n     *\n     * When using cache expiration, calling this method is preferable to calling\n     * `caches.delete()` directly, since this will ensure that the IndexedDB\n     * metadata is also cleanly removed and open IndexedDB instances are deleted.\n     *\n     * Note that if you're *not* using cache expiration for a given cache, calling\n     * `caches.delete()` and passing in the cache's name should be sufficient.\n     * There is no Workbox-specific method needed for cleanup in that case.\n     */\n    async deleteCacheAndMetadata() {\n        // Do this one at a time instead of all at once via `Promise.all()` to\n        // reduce the chance of inconsistency if a promise rejects.\n        for (const [cacheName, cacheExpiration] of this._cacheExpirations) {\n            await self.caches.delete(cacheName);\n            await cacheExpiration.delete();\n        }\n        // Reset this._cacheExpirations to its initial state.\n        this._cacheExpirations = new Map();\n    }\n}\nexport { ExpirationPlugin };\n", "\"use strict\";\n// @ts-ignore\ntry {\n    self['workbox:recipes:6.5.3'] && _();\n}\ncatch (e) { }\n", "/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { registerRoute } from 'workbox-routing/registerRoute.js';\nimport { StaleWhileRevalidate } from 'workbox-strategies/StaleWhileRevalidate.js';\nimport { CacheFirst } from 'workbox-strategies/CacheFirst.js';\nimport { CacheableResponsePlugin } from 'workbox-cacheable-response/CacheableResponsePlugin.js';\nimport { ExpirationPlugin } from 'workbox-expiration/ExpirationPlugin.js';\nimport './_version.js';\n/**\n * An implementation of the [Google fonts]{@link https://developers.google.com/web/tools/workbox/guides/common-recipes#google_fonts} caching recipe\n *\n * @memberof workbox-recipes\n *\n * @param {Object} [options]\n * @param {string} [options.cachePrefix] Cache prefix for caching stylesheets and webfonts. Defaults to google-fonts\n * @param {number} [options.maxAgeSeconds] Maximum age, in seconds, that font entries will be cached for. Defaults to 1 year\n * @param {number} [options.maxEntries] Maximum number of fonts that will be cached. Defaults to 30\n */\nfunction googleFontsCache(options = {}) {\n    const sheetCacheName = `${options.cachePrefix || 'google-fonts'}-stylesheets`;\n    const fontCacheName = `${options.cachePrefix || 'google-fonts'}-webfonts`;\n    const maxAgeSeconds = options.maxAgeSeconds || 60 * 60 * 24 * 365;\n    const maxEntries = options.maxEntries || 30;\n    // Cache the Google Fonts stylesheets with a stale-while-revalidate strategy.\n    registerRoute(({ url }) => url.origin === 'https://fonts.googleapis.com', new StaleWhileRevalidate({\n        cacheName: sheetCacheName,\n    }));\n    // Cache the underlying font files with a cache-first strategy for 1 year.\n    registerRoute(({ url }) => url.origin === 'https://fonts.gstatic.com', new CacheFirst({\n        cacheName: fontCacheName,\n        plugins: [\n            new CacheableResponsePlugin({\n                statuses: [0, 200],\n            }),\n            new ExpirationPlugin({\n                maxAgeSeconds,\n                maxEntries,\n            }),\n        ],\n    }));\n}\nexport { googleFontsCache };\n", "import './_version.js';\n/**\n * @memberof workbox-recipes\n \n * @param {Object} options\n * @param {string[]} options.urls Paths to warm the strategy's cache with\n * @param {Strategy} options.strategy Strategy to use\n */\nfunction warmStrategyCache(options) {\n    self.addEventListener('install', (event) => {\n        const done = options.urls.map((path) => options.strategy.handleAll({\n            event,\n            request: new Request(path),\n        })[1]);\n        event.waitUntil(Promise.all(done));\n    });\n}\nexport { warmStrategyCache };\n", "/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { warmStrategyCache } from './warmStrategyCache';\nimport { registerRoute } from 'workbox-routing/registerRoute.js';\nimport { CacheFirst } from 'workbox-strategies/CacheFirst.js';\nimport { CacheableResponsePlugin } from 'workbox-cacheable-response/CacheableResponsePlugin.js';\nimport { ExpirationPlugin } from 'workbox-expiration/ExpirationPlugin.js';\nimport './_version.js';\n/**\n * An implementation of the [image caching recipe]{@link https://developers.google.com/web/tools/workbox/guides/common-recipes#caching_images}\n *\n * @memberof workbox-recipes\n *\n * @param {Object} [options]\n * @param {string} [options.cacheName] Name for cache. Defaults to images\n * @param {RouteMatchCallback} [options.matchCallback] Workbox callback function to call to match to. Defaults to request.destination === 'image';\n * @param {number} [options.maxAgeSeconds] Maximum age, in seconds, that font entries will be cached for. Defaults to 30 days\n * @param {number} [options.maxEntries] Maximum number of images that will be cached. Defaults to 60\n * @param {WorkboxPlugin[]} [options.plugins] Additional plugins to use for this recipe\n * @param {string[]} [options.warmCache] Paths to call to use to warm this cache\n */\nfunction imageCache(options = {}) {\n    const defaultMatchCallback = ({ request }) => request.destination === 'image';\n    const cacheName = options.cacheName || 'images';\n    const matchCallback = options.matchCallback || defaultMatchCallback;\n    const maxAgeSeconds = options.maxAgeSeconds || 30 * 24 * 60 * 60;\n    const maxEntries = options.maxEntries || 60;\n    const plugins = options.plugins || [];\n    plugins.push(new CacheableResponsePlugin({\n        statuses: [0, 200],\n    }));\n    plugins.push(new ExpirationPlugin({\n        maxEntries,\n        maxAgeSeconds,\n    }));\n    const strategy = new CacheFirst({\n        cacheName,\n        plugins,\n    });\n    registerRoute(matchCallback, strategy);\n    // Warms the cache\n    if (options.warmCache) {\n        warmStrategyCache({ urls: options.warmCache, strategy });\n    }\n}\nexport { imageCache };\n", "/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { warmStrategyCache } from './warmStrategyCache';\nimport { registerRoute } from 'workbox-routing/registerRoute.js';\nimport { StaleWhileRevalidate } from 'workbox-strategies/StaleWhileRevalidate.js';\nimport { CacheableResponsePlugin } from 'workbox-cacheable-response/CacheableResponsePlugin.js';\nimport './_version.js';\n/**\n * An implementation of the [CSS and JavaScript files recipe]{@link https://developers.google.com/web/tools/workbox/guides/common-recipes#cache_css_and_javascript_files}\n *\n * @memberof workbox-recipes\n *\n * @param {Object} [options]\n * @param {string} [options.cacheName] Name for cache. Defaults to static-resources\n * @param {RouteMatchCallback} [options.matchCallback] Workbox callback function to call to match to. Defaults to request.destination === 'style' || request.destination === 'script' || request.destination === 'worker';\n * @param {WorkboxPlugin[]} [options.plugins] Additional plugins to use for this recipe\n * @param {string[]} [options.warmCache] Paths to call to use to warm this cache\n */\nfunction staticResourceCache(options = {}) {\n    const defaultMatchCallback = ({ request }) => request.destination === 'style' ||\n        request.destination === 'script' ||\n        request.destination === 'worker';\n    const cacheName = options.cacheName || 'static-resources';\n    const matchCallback = options.matchCallback || defaultMatchCallback;\n    const plugins = options.plugins || [];\n    plugins.push(new CacheableResponsePlugin({\n        statuses: [0, 200],\n    }));\n    const strategy = new StaleWhileRevalidate({\n        cacheName,\n        plugins,\n    });\n    registerRoute(matchCallback, strategy);\n    // Warms the cache\n    if (options.warmCache) {\n        warmStrategyCache({ urls: options.warmCache, strategy });\n    }\n}\nexport { staticResourceCache };\n", "/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { warmStrategyCache } from './warmStrategyCache';\nimport { registerRoute } from 'workbox-routing/registerRoute.js';\nimport { NetworkFirst } from 'workbox-strategies/NetworkFirst.js';\nimport { CacheableResponsePlugin } from 'workbox-cacheable-response/CacheableResponsePlugin.js';\nimport './_version.js';\n/**\n * An implementation of a page caching recipe with a network timeout\n *\n * @memberof workbox-recipes\n *\n * @param {Object} [options]\n * @param {string} [options.cacheName] Name for cache. Defaults to pages\n * @param {RouteMatchCallback} [options.matchCallback] Workbox callback function to call to match to. Defaults to request.mode === 'navigate';\n * @param {number} [options.networkTimoutSeconds] Maximum amount of time, in seconds, to wait on the network before falling back to cache. Defaults to 3\n * @param {WorkboxPlugin[]} [options.plugins] Additional plugins to use for this recipe\n * @param {string[]} [options.warmCache] Paths to call to use to warm this cache\n */\nfunction pageCache(options = {}) {\n    const defaultMatchCallback = ({ request }) => request.mode === 'navigate';\n    const cacheName = options.cacheName || 'pages';\n    const matchCallback = options.matchCallback || defaultMatchCallback;\n    const networkTimeoutSeconds = options.networkTimeoutSeconds || 3;\n    const plugins = options.plugins || [];\n    plugins.push(new CacheableResponsePlugin({\n        statuses: [0, 200],\n    }));\n    const strategy = new NetworkFirst({\n        networkTimeoutSeconds,\n        cacheName,\n        plugins,\n    });\n    // Registers the route\n    registerRoute(matchCallback, strategy);\n    // Warms the cache\n    if (options.warmCache) {\n        warmStrategyCache({ urls: options.warmCache, strategy });\n    }\n}\nexport { pageCache };\n", "/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { setCatchHandler } from 'workbox-routing/setCatchHandler.js';\nimport { matchPrecache } from 'workbox-precaching/matchPrecache.js';\nimport './_version.js';\n/**\n * An implementation of the [comprehensive fallbacks recipe]{@link https://developers.google.com/web/tools/workbox/guides/advanced-recipes#comprehensive_fallbacks}. Be sure to include the fallbacks in your precache injection\n *\n * @memberof workbox-recipes\n *\n * @param {Object} [options]\n * @param {string} [options.pageFallback] Precache name to match for pag fallbacks. Defaults to offline.html\n * @param {string} [options.imageFallback] Precache name to match for image fallbacks.\n * @param {string} [options.fontFallback] Precache name to match for font fallbacks.\n */\nfunction offlineFallback(options = {}) {\n    const pageFallback = options.pageFallback || 'offline.html';\n    const imageFallback = options.imageFallback || false;\n    const fontFallback = options.fontFallback || false;\n    self.addEventListener('install', (event) => {\n        const files = [pageFallback];\n        if (imageFallback) {\n            files.push(imageFallback);\n        }\n        if (fontFallback) {\n            files.push(fontFallback);\n        }\n        event.waitUntil(self.caches\n            .open('workbox-offline-fallbacks')\n            .then((cache) => cache.addAll(files)));\n    });\n    const handler = async (options) => {\n        const dest = options.request.destination;\n        const cache = await self.caches.open('workbox-offline-fallbacks');\n        if (dest === 'document') {\n            const match = (await matchPrecache(pageFallback)) ||\n                (await cache.match(pageFallback));\n            return match || Response.error();\n        }\n        if (dest === 'image' && imageFallback !== false) {\n            const match = (await matchPrecache(imageFallback)) ||\n                (await cache.match(imageFallback));\n            return match || Response.error();\n        }\n        if (dest === 'font' && fontFallback !== false) {\n            const match = (await matchPrecache(fontFallback)) ||\n                (await cache.match(fontFallback));\n            return match || Response.error();\n        }\n        return Response.error();\n    };\n    setCatchHandler(handler);\n}\nexport { offlineFallback };\n"],
  "mappings": "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",
  "names": ["options"]
}
