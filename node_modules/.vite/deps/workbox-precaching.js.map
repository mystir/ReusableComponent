{
  "version": 3,
  "sources": ["../../workbox-precaching/addPlugins.js", "../../workbox-precaching/utils/removeIgnoredSearchParams.js", "../../workbox-precaching/utils/generateURLVariations.js", "../../workbox-precaching/PrecacheRoute.js", "../../workbox-precaching/addRoute.js", "../../workbox-precaching/utils/deleteOutdatedCaches.js", "../../workbox-precaching/cleanupOutdatedCaches.js", "../../workbox-precaching/createHandlerBoundToURL.js", "../../workbox-precaching/getCacheKeyForURL.js", "../../workbox-precaching/precache.js", "../../workbox-precaching/precacheAndRoute.js", "../../workbox-precaching/PrecacheFallbackPlugin.js"],
  "sourcesContent": ["/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { getOrCreatePrecacheController } from './utils/getOrCreatePrecacheController.js';\nimport './_version.js';\n/**\n * Adds plugins to the precaching strategy.\n *\n * @param {Array<Object>} plugins\n *\n * @memberof workbox-precaching\n */\nfunction addPlugins(plugins) {\n    const precacheController = getOrCreatePrecacheController();\n    precacheController.strategy.plugins.push(...plugins);\n}\nexport { addPlugins };\n", "/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * Removes any URL search parameters that should be ignored.\n *\n * @param {URL} urlObject The original URL.\n * @param {Array<RegExp>} ignoreURLParametersMatching RegExps to test against\n * each search parameter name. Matches mean that the search parameter should be\n * ignored.\n * @return {URL} The URL with any ignored search parameters removed.\n *\n * @private\n * @memberof workbox-precaching\n */\nexport function removeIgnoredSearchParams(urlObject, ignoreURLParametersMatching = []) {\n    // Convert the iterable into an array at the start of the loop to make sure\n    // deletion doesn't mess up iteration.\n    for (const paramName of [...urlObject.searchParams.keys()]) {\n        if (ignoreURLParametersMatching.some((regExp) => regExp.test(paramName))) {\n            urlObject.searchParams.delete(paramName);\n        }\n    }\n    return urlObject;\n}\n", "/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { removeIgnoredSearchParams } from './removeIgnoredSearchParams.js';\nimport '../_version.js';\n/**\n * Generator function that yields possible variations on the original URL to\n * check, one at a time.\n *\n * @param {string} url\n * @param {Object} options\n *\n * @private\n * @memberof workbox-precaching\n */\nexport function* generateURLVariations(url, { ignoreURLParametersMatching = [/^utm_/, /^fbclid$/], directoryIndex = 'index.html', cleanURLs = true, urlManipulation, } = {}) {\n    const urlObject = new URL(url, location.href);\n    urlObject.hash = '';\n    yield urlObject.href;\n    const urlWithoutIgnoredParams = removeIgnoredSearchParams(urlObject, ignoreURLParametersMatching);\n    yield urlWithoutIgnoredParams.href;\n    if (directoryIndex && urlWithoutIgnoredParams.pathname.endsWith('/')) {\n        const directoryURL = new URL(urlWithoutIgnoredParams.href);\n        directoryURL.pathname += directoryIndex;\n        yield directoryURL.href;\n    }\n    if (cleanURLs) {\n        const cleanURL = new URL(urlWithoutIgnoredParams.href);\n        cleanURL.pathname += '.html';\n        yield cleanURL.href;\n    }\n    if (urlManipulation) {\n        const additionalURLs = urlManipulation({ url: urlObject });\n        for (const urlToAttempt of additionalURLs) {\n            yield urlToAttempt.href;\n        }\n    }\n}\n", "/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { Route } from 'workbox-routing/Route.js';\nimport { generateURLVariations } from './utils/generateURLVariations.js';\nimport './_version.js';\n/**\n * A subclass of {@link workbox-routing.Route} that takes a\n * {@link workbox-precaching.PrecacheController}\n * instance and uses it to match incoming requests and handle fetching\n * responses from the precache.\n *\n * @memberof workbox-precaching\n * @extends workbox-routing.Route\n */\nclass PrecacheRoute extends Route {\n    /**\n     * @param {PrecacheController} precacheController A `PrecacheController`\n     * instance used to both match requests and respond to fetch events.\n     * @param {Object} [options] Options to control how requests are matched\n     * against the list of precached URLs.\n     * @param {string} [options.directoryIndex=index.html] The `directoryIndex` will\n     * check cache entries for a URLs ending with '/' to see if there is a hit when\n     * appending the `directoryIndex` value.\n     * @param {Array<RegExp>} [options.ignoreURLParametersMatching=[/^utm_/, /^fbclid$/]] An\n     * array of regex's to remove search params when looking for a cache match.\n     * @param {boolean} [options.cleanURLs=true] The `cleanURLs` option will\n     * check the cache for the URL with a `.html` added to the end of the end.\n     * @param {workbox-precaching~urlManipulation} [options.urlManipulation]\n     * This is a function that should take a URL and return an array of\n     * alternative URLs that should be checked for precache matches.\n     */\n    constructor(precacheController, options) {\n        const match = ({ request, }) => {\n            const urlsToCacheKeys = precacheController.getURLsToCacheKeys();\n            for (const possibleURL of generateURLVariations(request.url, options)) {\n                const cacheKey = urlsToCacheKeys.get(possibleURL);\n                if (cacheKey) {\n                    const integrity = precacheController.getIntegrityForCacheKey(cacheKey);\n                    return { cacheKey, integrity };\n                }\n            }\n            if (process.env.NODE_ENV !== 'production') {\n                logger.debug(`Precaching did not find a match for ` + getFriendlyURL(request.url));\n            }\n            return;\n        };\n        super(match, precacheController.strategy);\n    }\n}\nexport { PrecacheRoute };\n", "/*\n  Copyright 2019 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { registerRoute } from 'workbox-routing/registerRoute.js';\nimport { getOrCreatePrecacheController } from './utils/getOrCreatePrecacheController.js';\nimport { PrecacheRoute } from './PrecacheRoute.js';\nimport './_version.js';\n/**\n * Add a `fetch` listener to the service worker that will\n * respond to\n * [network requests]{@link https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers#Custom_responses_to_requests}\n * with precached assets.\n *\n * Requests for assets that aren't precached, the `FetchEvent` will not be\n * responded to, allowing the event to fall through to other `fetch` event\n * listeners.\n *\n * @param {Object} [options] See the {@link workbox-precaching.PrecacheRoute}\n * options.\n *\n * @memberof workbox-precaching\n */\nfunction addRoute(options) {\n    const precacheController = getOrCreatePrecacheController();\n    const precacheRoute = new PrecacheRoute(precacheController, options);\n    registerRoute(precacheRoute);\n}\nexport { addRoute };\n", "/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\nconst SUBSTRING_TO_FIND = '-precache-';\n/**\n * Cleans up incompatible precaches that were created by older versions of\n * Workbox, by a service worker registered under the current scope.\n *\n * This is meant to be called as part of the `activate` event.\n *\n * This should be safe to use as long as you don't include `substringToFind`\n * (defaulting to `-precache-`) in your non-precache cache names.\n *\n * @param {string} currentPrecacheName The cache name currently in use for\n * precaching. This cache won't be deleted.\n * @param {string} [substringToFind='-precache-'] Cache names which include this\n * substring will be deleted (excluding `currentPrecacheName`).\n * @return {Array<string>} A list of all the cache names that were deleted.\n *\n * @private\n * @memberof workbox-precaching\n */\nconst deleteOutdatedCaches = async (currentPrecacheName, substringToFind = SUBSTRING_TO_FIND) => {\n    const cacheNames = await self.caches.keys();\n    const cacheNamesToDelete = cacheNames.filter((cacheName) => {\n        return (cacheName.includes(substringToFind) &&\n            cacheName.includes(self.registration.scope) &&\n            cacheName !== currentPrecacheName);\n    });\n    await Promise.all(cacheNamesToDelete.map((cacheName) => self.caches.delete(cacheName)));\n    return cacheNamesToDelete;\n};\nexport { deleteOutdatedCaches };\n", "/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { deleteOutdatedCaches } from './utils/deleteOutdatedCaches.js';\nimport './_version.js';\n/**\n * Adds an `activate` event listener which will clean up incompatible\n * precaches that were created by older versions of Workbox.\n *\n * @memberof workbox-precaching\n */\nfunction cleanupOutdatedCaches() {\n    // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n    self.addEventListener('activate', ((event) => {\n        const cacheName = cacheNames.getPrecacheName();\n        event.waitUntil(deleteOutdatedCaches(cacheName).then((cachesDeleted) => {\n            if (process.env.NODE_ENV !== 'production') {\n                if (cachesDeleted.length > 0) {\n                    logger.log(`The following out-of-date precaches were cleaned up ` +\n                        `automatically:`, cachesDeleted);\n                }\n            }\n        }));\n    }));\n}\nexport { cleanupOutdatedCaches };\n", "/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { getOrCreatePrecacheController } from './utils/getOrCreatePrecacheController.js';\nimport './_version.js';\n/**\n * Helper function that calls\n * {@link PrecacheController#createHandlerBoundToURL} on the default\n * {@link PrecacheController} instance.\n *\n * If you are creating your own {@link PrecacheController}, then call the\n * {@link PrecacheController#createHandlerBoundToURL} on that instance,\n * instead of using this function.\n *\n * @param {string} url The precached URL which will be used to lookup the\n * `Response`.\n * @param {boolean} [fallbackToNetwork=true] Whether to attempt to get the\n * response from the network if there's a precache miss.\n * @return {workbox-routing~handlerCallback}\n *\n * @memberof workbox-precaching\n */\nfunction createHandlerBoundToURL(url) {\n    const precacheController = getOrCreatePrecacheController();\n    return precacheController.createHandlerBoundToURL(url);\n}\nexport { createHandlerBoundToURL };\n", "/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { getOrCreatePrecacheController } from './utils/getOrCreatePrecacheController.js';\nimport './_version.js';\n/**\n * Takes in a URL, and returns the corresponding URL that could be used to\n * lookup the entry in the precache.\n *\n * If a relative URL is provided, the location of the service worker file will\n * be used as the base.\n *\n * For precached entries without revision information, the cache key will be the\n * same as the original URL.\n *\n * For precached entries with revision information, the cache key will be the\n * original URL with the addition of a query parameter used for keeping track of\n * the revision info.\n *\n * @param {string} url The URL whose cache key to look up.\n * @return {string} The cache key that corresponds to that URL.\n *\n * @memberof workbox-precaching\n */\nfunction getCacheKeyForURL(url) {\n    const precacheController = getOrCreatePrecacheController();\n    return precacheController.getCacheKeyForURL(url);\n}\nexport { getCacheKeyForURL };\n", "/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { getOrCreatePrecacheController } from './utils/getOrCreatePrecacheController.js';\nimport './_version.js';\n/**\n * Adds items to the precache list, removing any duplicates and\n * stores the files in the\n * {@link workbox-core.cacheNames|\"precache cache\"} when the service\n * worker installs.\n *\n * This method can be called multiple times.\n *\n * Please note: This method **will not** serve any of the cached files for you.\n * It only precaches files. To respond to a network request you call\n * {@link workbox-precaching.addRoute}.\n *\n * If you have a single array of files to precache, you can just call\n * {@link workbox-precaching.precacheAndRoute}.\n *\n * @param {Array<Object|string>} [entries=[]] Array of entries to precache.\n *\n * @memberof workbox-precaching\n */\nfunction precache(entries) {\n    const precacheController = getOrCreatePrecacheController();\n    precacheController.precache(entries);\n}\nexport { precache };\n", "/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { addRoute } from './addRoute.js';\nimport { precache } from './precache.js';\nimport './_version.js';\n/**\n * This method will add entries to the precache list and add a route to\n * respond to fetch events.\n *\n * This is a convenience method that will call\n * {@link workbox-precaching.precache} and\n * {@link workbox-precaching.addRoute} in a single call.\n *\n * @param {Array<Object|string>} entries Array of entries to precache.\n * @param {Object} [options] See the\n * {@link workbox-precaching.PrecacheRoute} options.\n *\n * @memberof workbox-precaching\n */\nfunction precacheAndRoute(entries, options) {\n    precache(entries);\n    addRoute(options);\n}\nexport { precacheAndRoute };\n", "/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { getOrCreatePrecacheController } from './utils/getOrCreatePrecacheController.js';\nimport './_version.js';\n/**\n * `PrecacheFallbackPlugin` allows you to specify an \"offline fallback\"\n * response to be used when a given strategy is unable to generate a response.\n *\n * It does this by intercepting the `handlerDidError` plugin callback\n * and returning a precached response, taking the expected revision parameter\n * into account automatically.\n *\n * Unless you explicitly pass in a `PrecacheController` instance to the\n * constructor, the default instance will be used. Generally speaking, most\n * developers will end up using the default.\n *\n * @memberof workbox-precaching\n */\nclass PrecacheFallbackPlugin {\n    /**\n     * Constructs a new PrecacheFallbackPlugin with the associated fallbackURL.\n     *\n     * @param {Object} config\n     * @param {string} config.fallbackURL A precached URL to use as the fallback\n     *     if the associated strategy can't generate a response.\n     * @param {PrecacheController} [config.precacheController] An optional\n     *     PrecacheController instance. If not provided, the default\n     *     PrecacheController will be used.\n     */\n    constructor({ fallbackURL, precacheController, }) {\n        /**\n         * @return {Promise<Response>} The precache response for the fallback URL.\n         *\n         * @private\n         */\n        this.handlerDidError = () => this._precacheController.matchPrecache(this._fallbackURL);\n        this._fallbackURL = fallbackURL;\n        this._precacheController =\n            precacheController || getOrCreatePrecacheController();\n    }\n}\nexport { PrecacheFallbackPlugin };\n"],
  "mappings": "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",
  "names": ["cacheNames"]
}
